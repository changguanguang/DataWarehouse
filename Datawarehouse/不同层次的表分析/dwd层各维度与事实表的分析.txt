1. 用户行为数据
	- 分析每个统计表中在原生日志信息中包含的特定的字段,过滤
	- 使用 get_json_obejct 来对json字符串以及json数组进行解析
	- 自定义 UDTF函数 ,explode_json_Array 炸开json数组(普通的炸裂数组作用有限,对于表中的普通集合,指定分割符,直接炸裂)
	
2. 用户业务数据
	- 商品维度表 (全量):
		- 合并商品表类,将将商品表 SKU 表、商品一级分类、商品二级分类、商品三级分类、商品品牌表和商品 SPU 表退化为商品表。减少后续的join操作
		- 将各个字段所在的表进行等值连接(join),并不存在为null的情况
	- 优惠卷维度表(全量)
		- 直接导入即可
	- 活动维度表(全量)
		- 直接导入即可
	- 地区维度表(特殊)
		- 省份与地区进行join,字段等值连接
	- 时间维度表(特殊)
		- 这里dwd_dim_date_info 是parquet存储＋ lzo压缩,直接从本地导入时间表,并不会自动转换,需要使用中间表,进行导入.
		- 创建中间表 			dwd_dim_date_info_tmp
		- 将数据导入中间表
			load data local inpath '/opt/module/db_log/date_info.txt' into tabledwd_dim_date_info_tmp;
		- 中间表导入正式表
			insert overwrite table dwd_dim_date_info select * from dwd_dim_date_info_tmp;
			
	- 支付事实表(事务型事实表)
		- 判断支付事实表与各个维度的相关性(dwd维度建模)
		- 确定事实表中的字段
		
		- join等值连接某天的数据,增加原表中的字段
	- 退款事实表(事务型事实表)
		- 同上
		- 事务型事实表比较简单,以往的数据不会发生该表,直接将新的一天的数据处理后直接加载到实施表中就可以.
	- 评价事实表(事务型事实表)
	- 订单明细事实表(事务型事实表)
		- 订单明细(主键:每个订单的每个商品)
		- 新字段: 原始价格分摊,运费分摊,优惠分摊,最终价格分摊
		- 涉及到价格分摊公式 && 计算后会有价格差
		- 解决:
			①先得到普通的价格分摊表
			②开窗排序
			③对得到的表,计算差价加到排名第一的商品上
		- 使用到的函数与技术:
			① round(number,n) 对number保留n位数 
			②开窗 over(partition by .. order by..)
			③开窗排序 row_number()<是不会出现重复的行号的>
	- 加购事实表(周期性快照事实表,每日快照)
		- 购物车数量会发生变化,到增量不合适
		- 每天做一次快照,导入全量数据
		- 周期性快照事实表 劣势: 存储的数据会很大
		- 解决方案: 周期型快照事实表存储的数据比较讲究时效性，时间太久了的意义不大，可以删除以前的数据。
	
	- 收藏事实表(周期性快照事实表,每日快照)
		- 收藏会发生变化,做增量不合适
		- 导全量
	- 优惠卷领用事实表(累积性快照事实表)
		- 优惠卷的生命周期：		领取优惠卷->用优惠卷下单->优惠卷参与支付
		- 每日ods层导入新增和变化
		- 将昨天的表和今天ods新增的数据进行合并 full outer join 
		- 使用空值判断函数判断 nvl 或 if
		
		- 动态分区(将分区号在查询中动态确定):
			① set hive.exec.dynamic.partition.mode=nonstrict;
			② 优惠卷领用事实表 按照 get_time()进行分区,所以变化的数据需要放置到原分区中,根据字段get_time确定分区号
	- 订单事实表（累积型快照事实表）
		- 订单生命周期：			创建时间=>支付时间=>取消时间=>完成时间=>退款时间=>退款完成时间。
		- 使用到的函数与技术：
			① concat（）
			② concat_ws()
			③ str_to_map() 将普通的text转化为map,方便使用
			④ date_format()
		- 思路:
			将订单状态表中的数据按照orderId分组处理,将对应的状态与时间聚合 转化为Map
	- 用户维度表(拉链表):
		- 什么是拉链表:
			记录每条信息的生命周期,一旦一条记录生命周期结束,就重新开始一条新的记录,并把当前日期放入到生效开始日期
		- 为社么要用拉链表
			
		- 什么时候要用拉链表?
			数据会发生变化,但大部分是不变的(缓慢变化维)
		
		- 如何使用拉链表?
			这个表是新增和变化表,由于hive表不支持修改更新,所以都是将旧表和新增的数据合并(union或full outer join)覆盖原表.
			使用union是因为 经过改变的用户信息会有两条,
	
	
	
	
	
	
	
	
	
	
	
	
	
	